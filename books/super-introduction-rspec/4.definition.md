---
title: "テストコードの要件定義"
---
テストコードの書き方を簡単に復習したので、試しにテストコードを書いてみるものの...
**「よし！さっそくテストを書いてみるぞ！！」**
**「...何から書き始めればいいんだ？？」**

...と悩まれる方が多いと思います。
こちらのチャプターでは以下の記事を参考にして、`どういうテストを書いていくべきか？`という内容を重点的に説明していきます。
https://qiita.com/jnchito/items/2a5d3e15761fd413657a
- - -
## テストの対象になるコード
大きく分けると以下の4つになります。
1. 主要なユースケース
まずユーザーがメインで使う機能をテストコードに書いていきます。基本的な掲示板アプリであれば「**ユーザー登録・ログイン**」、「**書籍一覧、登録、編集**」などのCRUD機能ですね。
主要な機能のテストコードを書いておくことで、リリースする前にブラウザ上にて**手作業と目視**でチェックする**時間と手間**を省くことが出来ます。
2. 条件分岐や例外処理
`if`のテストにおいて片方しか書いていない場合、テストは自体は通っていても片方のルートでエラーが出てしまう可能性があります。
また最初は正常に動いていたコードも、リファクタリング後に不具合が発生する可能性も考えられますので、**条件分岐**は`true`と`false`両方書くようにしましょう。
[**例外処理**](https://zenn.dev/siesta0905/books/79194452fd34ae/viewer/149c5c)についてはイベント後半に解説いたします。

今回のイベントでは上記のテストコードを書いていきますが、実務になると以下のテストケースも考えていきます。

:::details 複雑なロジック、セキュリティなど
3. 複雑なロジックや書いていて不安になるコード
一つのメソッドの中に「2個、3個と重なってしまい**複雑化してしまった条件分岐**」や「**複数存在している計算処理**」などのコードはバグや不具合が発生しやすくなります。
リリース後に発覚するのを防ぐため、慎重にテストコードを書いていく必要があります。
※複雑化することが想定されるコードの場合、コードと同時にテストを並行して書いていくとテスト抜けが少なくなると思います。
4. セキュリティや金銭に関わるコード
・**セキュリティ**
**認証**や**認可**などの**権限管理**周りや、ユーザーによる**攻撃**{XSS(クロスサイトスクリプティング)、SQLインジェクションなど}を防げているかなどをテストします。
・**金銭**
**課金要素のある機能**や**決済を扱う機能**などの**お金を扱っている箇所**をテストします。<br>
上記のような**不具合が出てしまうと致命的な結果**になってしまう部分は、必ず書いていく必要があります。
:::
- - -
しかし、初学者がこれらのテストケースを全て書くというのは**非常に困難**です。
最初は以下の内容を意識して取り組まれたら良いかと思います。
- 最初から完璧を目指すのではなく、「**重要な部分**」と「**不安な部分**」からテストを書き始める
- テストカバレッジツール(SimpleCov)を使用し、テスト範囲の網羅率を簡単に把握する

**カバレッジ**と**テストの網羅率**については次のパートで解説します。
## カバレッジと網羅率の基準
### カバレッジ
カバレッジとはアプリ全体のコードに対して、**どのくらいの範囲までテストを実行出来ているか**を示す指標(**網羅率**)になります。
カバレッジの網羅率が高いほど、広い範囲でバグの早期発見に繋げることが出来ます。
#### カバレッジの評価基準
カバレッジには主に3つの評価基準が存在しています。
基本的には**条件分岐**に対しての実行結果で判定しています。今回のイベント内では**C1カバレッジ**を採用します。
言葉のみだと理解しづらい概念がと思いますので、各カバレッジテストケースが理解しやすいように、以下のコードを作成しました。
```ruby:書籍ECサイトの購入条件
def can_purchase?(in_stock, user_signed_in)
  if in_stock && user_signed_in
    "購入可能"
  else
    "購入不可"
  end
end
```
上記の**ECサイト購入機能**を元にテストケースを定義していきます。
- ステートメントカバレッジ(C0)
各メソッドのテストを実行されているかをチェックするカバレッジになります。
メソッドの処理を一回でも実行されていれば完了するので、手軽に実装出来るカバレッジになります。<br>
なのでテストケースは**一つだけ**あればC0カバレッジは成立します。
:::details C0テストコード
```ruby:system_specテスト
describe "Book#can_purchase?" do
  context "正常系のテストケース" do
    it "書籍の在庫がある＆ログイン済みの場合、本を購入出来る" do
      〜〜
    end
  end
end
```
```ruby:書籍ECサイトの購入条件
def can_purchase?(in_stock, user_signed_in)
  if in_stock && user_signed_in # どちらもtrue
    "購入可能" # trueの分岐のみテストが実行される
  else
    "購入不可" # falseのテストは存在しないため、実行されず
  end
end
```
|      | in_stock | user_signed_in |結果|
| ---- | -------- | ------------- | --- |
| テストケース1 | true | true | true|

`true`のみのテストを網羅したテストケースになります。一つのメソッドに対して1つ書けばいいので、今回は**1個**のテストを作成しました。
:::
- ブランチカバレッジ(C1)
各メソッドの条件分岐(true,false)をそれぞれテストされているかをチェックするカバレッジになります。
条件分岐を全て通るので、C0よりもテストの評価基準は高くなります。
:::details C1テストコード
```ruby:system_specテスト
describe "Book#can_purchase?" do
  context "正常系のテストケース" do
    it "書籍の在庫がある＆ログイン済みの場合、本を購入出来る" do
      〜〜
    end
    it "書籍の在庫が無い＆ログインをしていない場合、本を購入出来ない" do
      〜〜
  end
end
```
```ruby:書籍ECサイトの購入条件
def can_purchase?(in_stock, user_signed_in)
  if in_stock && user_signed_in # どちらもtrue ＆ どちらもfalse
    "購入可能" # trueのテストが実行される
  else
    "購入不可" # falseのテストも実行される
  end
end
```
|      | in_stock | user_signed_in |結果|
| ---- | -------- | ------------- | --- |
| テストケース1 | true | true | true |
| テストケース2 | false | false | false |

`true`と`false`のテストを網羅したテストケースになります。分岐の数テストを書くので、今回は**2個**のテストを作成しました。
:::
- マルチコンディションカバレッジ(C2)
単体の条件分岐だけでなく、複数の条件分岐(and,or)を全てテストしているかチェックするカバレッジになります。
**複雑な条件分岐**でも対応出来るため、テストの網羅性は非常に高いです。しかし条件式が増えていくと極端にテストケースが増えていくので、開発者の負担が大きくなります。
:::details C2テストコード
```ruby:system_specテスト
describe "Book#can_purchase?" do
  context "正常系のテストケース" do
    it "書籍の在庫がある＆ログイン済みの場合、本を購入できる" do
      〜〜
    end
    it "書籍の在庫が無い＆ログインをしていない場合、本を購入出来ない" do
      〜〜
    end
    it "書籍の在庫がある＆ログインをしていない場合、本を購入できない" do
      〜〜
    end
    it "書籍の在庫が無い＆ログイン済みの場合、本を購入できる" do
      ~~
    end
  end
end
```
```ruby:書籍ECサイトの購入条件
def can_purchase?(in_stock, user_signed_in)
  if in_stock && user_signed_in # どちらもtrue ＆ どちらもfalse ＆ (in_stock - true, logged - false) ＆ (in_stock -false, logged - false)
    "購入可能" # trueのテストが実行される
  else
    "購入不可" # falseのテストが3つ実行される
  end
end
```
|      | in_stock | user_signed_in |結果|
| ---- | -------- | ------------- | --- |
| テストケース1 | true | true | true |
| テストケース2 | false | false | false |
| テストケース3 | true  | false | false  |
| テストケース4 | false | true  | false  |

`true`と`false`のテストを網羅しつつ、全ての条件を適用したテストケースになります。(分岐の数 + 複数条件)テストを書くので、今回は**4個**のテストを作成しました。
:::
- - -
テストコードを書いていくには、上記の**カバレッジ基準**と**網羅率**を意識する必要があります。
しかし一つ一つメソッドを確認して網羅率を計算していると、とんでもない時間と労力が掛かってしまいますね。

そこでRailsには簡単にカバレッジの網羅率を測定できる便利なgemが存在します。
#### SimpleCov
**[gem SimpleCov](https://github.com/simplecov-ruby/simplecov)**とは、開発しているアプリのテストカバレッジを簡単に測定することが出来る**テストカバレッジツール**です。

今回のイベントで環境構築していただいたプロジェクトには既にインストールされています。
試しに以下のコマンドを実行してみましょう。
```
docker compose exec web bash -c "RAILS_ENV=test bundle exec rspec"
```
![SimpleCovの実行結果](/images/super-introduction-rspec/10eeea68d154019360ffd0712df80d50.png)
*テスト実行結果の最後にカバレッジの網羅率が表示されます*
画像のテスト実行を例にすると、195件の機能(クラスやメソッド)に対して152件のテストを実行出来ているので、網羅率は**77.95**%となります。環境構築をしたばかりでテスト対象が少ない為、高めの網羅率になっています。

今後機能を追加していく時には、**網羅率70〜80%以上**を基準にテストを書いていただくと、ある程度のテスト範囲を網羅出来るかと思います。
#### SimpleCovの注意点
しかしSimpleCovだけでC0、C1のカバレッジを完全に網羅することは難しいようです。
様々な理由がありますが、一つ具体例を挙げてみます。
- `else`を使った標準の`if`だとC1に対応出来るが、三項演算子などの`一行で完結する分岐`はC1に対応出来ない

```ruby:仮にnameに"Nobu"が格納されている場合の単体のテストコードを書いた場合
it "nameがNobuの場合はYes Nobuと返すこと" do
  expect(return_the_nobu).to eq("Yes Nobu")
end
```
```ruby:ifと三項演算子でのSimpleCovカバレッジ基準の違い
# 基本なifの場合
def return_the_nobu
  if name == "Nobu"
    "Yes Nobu"  # trueの処理に対してテストコードが実行される
  else
    "No"  # falseの処理にはテストコードが存在しない
  end
end
# Line Coverage: 50%  片方(true)の条件分岐のみ適用されるので、C1基準の50%という結果
---------------------------
# 三項演算子の場合
def return_the_nobu
  name == "Nobu" ? "Yes Nobu" : "No"  # trueの条件である"Yes Nobu"の処理が実行される
end                                   # しかし、1行でテストが完了されてしまうので...
# Line Coverage: 100%  C0基準の100%という結果に...
```
処理の内容としては同じですが、書き方によってカバレッジの基準が変化してしまいます。
なので事前にテスト要件を定義し、テストコードを書き終わった後の**最終確認**として使用するといいかもしれません。

SimpleCovのカバレッジ範囲については以下の記事に詳しく載っていますので、参考にしていただければと思います。
https://moneyforward-dev.jp/entry/2022/12/15/test-coverage-measurement/
## まとめ
RSpecの基本からテスト範囲の考え方を一通り説明させていただきました。
次からはハンズオン形式に移行しますので、テストコードをたくさん書いていきましょう！
https://zenn.dev/siesta0905/books/79194452fd34ae